<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>盆老板的烧饼铺</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-08-27T15:20:15.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Hannah He</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React初体验</title>
    <link href="http://yoursite.com/2016/08/27/react-first-sight/"/>
    <id>http://yoursite.com/2016/08/27/react-first-sight/</id>
    <published>2016-08-27T15:11:24.000Z</published>
    <updated>2016-08-27T15:20:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="components-are-just-state-machines"><a href="#components-are-just-state-machines" class="headerlink" title="components are just state machines"></a>components are just state machines</h3><p>components只是 承载state的容器，通过state的变化来实现components的渲染</p>
<h3 id="ownership-amp-父子关系"><a href="#ownership-amp-父子关系" class="headerlink" title="ownership &amp; 父子关系"></a>ownership &amp; 父子关系</h3><p>ownership：props和state是根据这种关系来传递数值，如果一个component在另一个component的render方法里定义，两者就存在ownership ，render中传递的值是当前定义的元素的props中<br>     父子关系是指在类似dom树结构的两个元素<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Parent&gt;</div><div class="line">	&lt;Child /&gt;</div><div class="line">&lt;/Parent&gt;</div></pre></td></tr></table></figure></p>
<p>在这种关系里，parent可以通过this.props.children来获取children 的 prop，也可以用 React.Children的相关操作对children进行操作</p>
<h3 id="react-dom操作的方式"><a href="#react-dom操作的方式" class="headerlink" title="react dom操作的方式"></a>react dom操作的方式</h3><p>react在操作dom上充分考虑了性能上的优化，比如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Card&gt;</div><div class="line">     &lt;p&gt;Paragraph 1&lt;/p&gt;</div><div class="line">     &lt;p&gt;Paragraph 2&lt;/p&gt;</div><div class="line">&lt;/Card&gt;</div></pre></td></tr></table></figure></p>
<p>如果想要删除第一个p，react不会直接destory这个元素，因为这样会触发下面所有元素的repaint；react采用的方式是destory最后一个元素，然后改变上面所有元素的值。这样的做法只需要一次render，改变值的操作只是一个repaint的方式。尤其是对于list，n个元素只需要做1次render和n-1次repaint。</p>
<p>但是有一种情况，就是当子元素的值是保存在state中的，这里最好不要采用destory的方式，因为当state发生改变时，会强制触发整个页面重新渲染，所以这时推荐的方式是将想要删除的元素display:none<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Card&gt;</div><div class="line">     &lt;pstyle=&#123;&#123;display:<span class="string">'none'</span>&#125;&#125;&gt;Paragraph 1&lt;/p&gt;</div><div class="line">     &lt;p&gt;Paragraph 2&lt;/p&gt;</div><div class="line">&lt;/Card&gt;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;components-are-just-state-machines&quot;&gt;&lt;a href=&quot;#components-are-just-state-machines&quot; class=&quot;headerlink&quot; title=&quot;components are just stat
    
    </summary>
    
    
      <category term="javascript React" scheme="http://yoursite.com/tags/javascript-React/"/>
    
  </entry>
  
  <entry>
    <title>H5中的video标签</title>
    <link href="http://yoursite.com/2016/05/10/h5-video/"/>
    <id>http://yoursite.com/2016/05/10/h5-video/</id>
    <published>2016-05-10T14:58:05.000Z</published>
    <updated>2016-07-13T12:07:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="格式问题"><a href="#格式问题" class="headerlink" title="格式问题"></a>格式问题</h2><p>video标签能够支持的格式有限，通常为mp4, webm, ogg这三种视频格式，可以通过列举多个视频格式预防某个视频文件出问题，但是这样同样也会出现视频多余加载的问题，推荐还是使用MP4，但需要注意的是，在大部分浏览器中（PC和移动端均存在），只能识别编码格式为H.264的编码格式，其他的编码格式浏览器不能正常解析，Chrome中会出现白屏（播放有声音但无图像），火狐上会提示“文件已损坏”。</p>
<p><img src="http://ww4.sinaimg.cn/large/59967359gw1f3pcey8tagj20cn09w751.jpg" alt="firefox error"></p>
<h2 id="封面问题"><a href="#封面问题" class="headerlink" title="封面问题"></a>封面问题</h2><p>如果视频加载成功，video自带的封面图会根据视频的宽高进行缩放，如果视频加载失败，则会根据图片的尺寸显示出播放区域</p>
<p><img src="http://ww3.sinaimg.cn/large/59967359gw1f3pcdlp82bj20ae06amxq.jpg" alt="correct show"></p>
<p><img src="http://ww1.sinaimg.cn/large/59967359gw1f3pce5av9ej20an0agabf.jpg" alt="wrong show"></p>
<p>最好用一个统一的封面加一个播放按钮，将视频隐藏，这里最好能把video标签用1px * 1px来隐藏，而不要display:none，因此display:none不会将视频激活，后续加载可能会耗时过长。不过这个有一个问题就是必须规定好视频的宽高比例，封面图片和视频保持一致，最好是可以截取视频的第一帧图像作为视频的封面。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;格式问题&quot;&gt;&lt;a href=&quot;#格式问题&quot; class=&quot;headerlink&quot; title=&quot;格式问题&quot;&gt;&lt;/a&gt;格式问题&lt;/h2&gt;&lt;p&gt;video标签能够支持的格式有限，通常为mp4, webm, ogg这三种视频格式，可以通过列举多个视频格式预防某个视频文件
    
    </summary>
    
    
      <category term="HTML5 javascript" scheme="http://yoursite.com/tags/HTML5-javascript/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2016/05/02/hello-world/"/>
    <id>http://yoursite.com/2016/05/02/hello-world/</id>
    <published>2016-05-02T13:13:33.000Z</published>
    <updated>2016-05-02T13:13:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS中4种function调用方法</title>
    <link href="http://yoursite.com/2016/05/02/JS-function-calls/"/>
    <id>http://yoursite.com/2016/05/02/JS-function-calls/</id>
    <published>2016-05-02T12:55:16.000Z</published>
    <updated>2016-05-02T13:13:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>JS中函数调用时会接收两个参数，this &amp; arguments，有4种调用方式，四种方式的区别在于this不同。</p>
<h2 id="方法模式"><a href="#方法模式" class="headerlink" title="方法模式"></a>方法模式</h2><p>将函数作为一个对象的属性，即为一个方法。调用时，通过对象来调用。这里的this是该对象。</p>
<p><img src="http://ww2.sinaimg.cn/large/59967359gw1f3hc778u1lj207g042aa2.jpg" alt="call1"></p>
<p><img src="http://ww4.sinaimg.cn/large/59967359gw1f3hc7wbac6j204v01rq2u.jpg" alt="call1 result"></p>
<h2 id="函数模式"><a href="#函数模式" class="headerlink" title="函数模式"></a>函数模式</h2><p>直接调用某个函数，this是全局对象window</p>
<p><img src="http://ww2.sinaimg.cn/large/59967359gw1f3hcak6o62j2088049q30.jpg" alt="call2"></p>
<p><img src="http://ww3.sinaimg.cn/large/59967359gw1f3hcbpxgjrj20840443z5.jpg" alt="call2 result"></p>
<h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><p>用new func()的方式来调用函数，实际是创建了一个连接到该函数的prototype成员的新对象。这里的this是函数自己。</p>
<p><img src="http://ww2.sinaimg.cn/large/59967359gw1f3hccz50sqj208v05174i.jpg" alt="call3"></p>
<p><img src="http://ww2.sinaimg.cn/large/59967359gw1f3hcdj050zj207h02hjrg.jpg" alt="call3 result"></p>
<h2 id="Apply调用模式"><a href="#Apply调用模式" class="headerlink" title="Apply调用模式"></a>Apply调用模式</h2><p>也可以用call，参数不同而已，apply是数组，call是一个逐个列出<br>apply允许设置this，即使对象并没有这个方法，仍然可以通过apply指定作用域，然后在某个对象上调用这个方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS中函数调用时会接收两个参数，this &amp;amp; arguments，有4种调用方式，四种方式的区别在于this不同。&lt;/p&gt;
&lt;h2 id=&quot;方法模式&quot;&gt;&lt;a href=&quot;#方法模式&quot; class=&quot;headerlink&quot; title=&quot;方法模式&quot;&gt;&lt;/a&gt;方法模式&lt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Node中的异步I／O</title>
    <link href="http://yoursite.com/2016/05/02/Node-I%EF%BC%8FO/"/>
    <id>http://yoursite.com/2016/05/02/Node-I／O/</id>
    <published>2016-05-02T12:41:35.000Z</published>
    <updated>2016-05-02T13:13:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>JS执行是单线程的，但是Node底层有一个线程池，使用多线程来实现异步I/O。</p>
<p><img src="http://ww1.sinaimg.cn/large/59967359gw1f3hbss9mssj207l05yt8o.jpg" alt="nodeio"></p>
<h2 id="几大要素"><a href="#几大要素" class="headerlink" title="几大要素"></a>几大要素</h2><p>事件循环、观察者、请求对象、I/O线程池。</p>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>进程启动，会创建一个while(true)的事件循环，每次是一个Tick，每个Tick就是查看是否有事件待处理，有事件则取出事件及回调，执行回调，没有则退出进程。</p>
<p><img src="http://ww4.sinaimg.cn/large/59967359gw1f3hbuo2qpej20am0c00tf.jpg" alt="event loop"></p>
<h3 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h3><p>事件循环判断是否有事件待执行，就是通过询问观察者，观察者不会主动通知进程，而是进程询问时才返回结果。<br>事件循环是生产者/消费者模型。异步I/O和网络请求是事件的生产者，这些事件被输送到观察者，事件循环是消费者，从观察者这里取出事件处理。观察者就相当于模型中的缓冲区，生产者不断产生事件放到缓冲区，而消费者从缓冲区里取出事件进行消费。</p>
<h3 id="请求对象"><a href="#请求对象" class="headerlink" title="请求对象"></a>请求对象</h3><p>Node底层实现异步I\O，依赖请求对象。<br>假设fs.open()，根据指定路径和参数打开文件，整个调用过程：</p>
<p><img src="http://ww2.sinaimg.cn/large/59967359gw1f3hbwg24ylj20dl0d73zk.jpg" alt="request object"></p>
<p>请求对象就在libuv这个过程创建，传入参数和当前方法都包含在这个对象中，然后再将改对象推入进程池中。<br>JS层面的请求会立即返回，继续执行后续的操作，而上面的操作都是在node层进行的，这个打开文件的请求会依赖请求对象在线程池中等待执行，执行完毕后执行相应的回调函数，而JS执行线程并不关心下面线程池里发生的事，当前的I/O操作不管是否阻塞I/O，都不会影响JS执行线程的执行，这就是异步。<br>总之，JS执行线程是单线程，而NODE底层有个线程池，这里进行多线程使用事件循环，实现异步I/O。请求对象既包括异步I/O的所有状态，从送入线程池到I/O操作后执行的回调。</p>
<h3 id="执行回调"><a href="#执行回调" class="headerlink" title="执行回调"></a>执行回调</h3><p>送入线程池是第一步，调用回调是第二步。关键是事件循环<br>I/O执行结束后，会将结果通知IOCP（windows下,linux下epoll），并将线程归还线程池。使用事件循环的I/O观察者，如果有已经执行完的I/O，则将请求对象加入I/O观察者队列中，事件循环再Tick过程中，检测到有I/O观察者，则取出其中的请求对象，再取出请求对象中的回调函数执行。</p>
<p><img src="http://ww4.sinaimg.cn/large/59967359gw1f3hbxyctd8j20la0e740v.jpg" alt="do callback"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h2&gt;&lt;p&gt;JS执行是单线程的，但是Node底层有一个线程池，使用多线程来实现异步I/O。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http:
    
    </summary>
    
    
      <category term="Nodejs" scheme="http://yoursite.com/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>exports &amp; Module.exports</title>
    <link href="http://yoursite.com/2016/05/02/exports-Module-exports/"/>
    <id>http://yoursite.com/2016/05/02/exports-Module-exports/</id>
    <published>2016-05-02T12:30:44.000Z</published>
    <updated>2016-05-02T13:13:33.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>exports对象是Node中的一个对外接口，其实是通过它为模块闭包提供一个有限的接口，只有exports对象导出的属性或者方法才能够被调用。一般有两种写法：exports.xxx= &amp; module.exports = {}</p>
</li>
<li><p>exports和module.exports大部分情况下是一样的，但是你可以理解成exports是module.exports的一个引用，如果对module.exports进行改变赋值，exports引用的还是之前的地址。就是不管exports设置了多少属性和方法，一旦module.exports进行了赋值，对外暴露的都是module.exports的内容.</p>
</li>
<li><p>不可以通过对 exports 直接赋值代替对 module.exports 赋值。exports 实际上只是一个和 module.exports 指向同一个对象的变量，它本身会在模块执行结束后释放，但 module 不会，因此只能通过指定module.exports 来改变访问接口。</p>
</li>
<li><p>可以使用module.exports = hello，这样来改变输出的对象（原来是exports，现在是hello），但不能直接用exports = hello，这样仍然会导出module.exports，也就是exports对象，不会导出hello.</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;exports对象是Node中的一个对外接口，其实是通过它为模块闭包提供一个有限的接口，只有exports对象导出的属性或者方法才能够被调用。一般有两种写法：exports.xxx= &amp;amp; module.exports = {}&lt;/p&gt;
&lt;/li&gt;

    
    </summary>
    
    
      <category term="javascript AMD" scheme="http://yoursite.com/tags/javascript-AMD/"/>
    
  </entry>
  
  <entry>
    <title>JS原型链继承中的小玩意</title>
    <link href="http://yoursite.com/2016/05/02/JS-Prototype/"/>
    <id>http://yoursite.com/2016/05/02/JS-Prototype/</id>
    <published>2016-05-02T06:27:32.000Z</published>
    <updated>2016-05-02T13:13:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="继承方法："><a href="#继承方法：" class="headerlink" title="继承方法："></a>继承方法：</h2><h3 id="1、原型链（主要）"><a href="#1、原型链（主要）" class="headerlink" title="1、原型链（主要）"></a>1、原型链（主要）</h3><p>每个构造函数有一个prototype原型对象，prototype指向constructor，constructor中又包含了一个指向prototype的指针（好像有点循环），而实例有一个proto指向prototype。<br>实现的本质是重写原型对象prototype，原本在SuperType中的属性和方法现在都存在于SubType.prototype中。SubType的原型指向SuperType的实例，SuperType的实例又包含了一个指向prototype的指针（应该是proto）</p>
<h3 id="2、最常用的是构造函数和原型链的组合"><a href="#2、最常用的是构造函数和原型链的组合" class="headerlink" title="2、最常用的是构造函数和原型链的组合"></a>2、最常用的是构造函数和原型链的组合</h3><p>原型链继承大家公共的方法和属性，构造函数继承实例的方法和属性。用法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">SubType</span></span>() &#123;</div><div class="line">  SuperType.call(this);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>单纯的构造函数的问题就在于方法都在SuperType中定义好了，不能复写了。</p>
<h2 id="继承后相关变量的变化"><a href="#继承后相关变量的变化" class="headerlink" title="继承后相关变量的变化"></a>继承后相关变量的变化</h2><p>看看下面这个代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">SuperType</span></span>() &#123;</div><div class="line">  this.aa = 1;</div><div class="line">  this.colors = [<span class="string">'red'</span>, <span class="string">'white'</span>];</div><div class="line">&#125;</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">SubType</span></span>() &#123;</div><div class="line">  SubType.prototype = new SuperType();</div><div class="line">&#125;</div><div class="line"></div><div class="line">var instance1 = new SubType();</div><div class="line">instance1.aa = 2;</div><div class="line">instance1.colors.push(<span class="string">'yellow'</span>);</div><div class="line"></div><div class="line">document.write(<span class="string">'instance1.aa='</span> + instance1.aa + <span class="string">'\n'</span> +</div><div class="line">                <span class="string">'instance1.colors='</span> + instance1.colors);</div><div class="line"></div><div class="line">var instance2 = new SubType();</div><div class="line">document.write(<span class="string">'instance2.aa='</span> + instance2.aa + <span class="string">'\n'</span> +</div><div class="line">                <span class="string">'instance2.colors='</span> + instance2.colors);</div></pre></td></tr></table></figure>
<p>这里的输出结果是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">instance1.aa=2 instance1.colors=red,white,yellow</div><div class="line">instance2.aa=1 instance2.colors=red,white,yellow</div></pre></td></tr></table></figure></p>
<p>这里会发现colors改变了，但是aa并没有改变。我们看看instance1和instance2里都有什么东西</p>
<p><img src="http://ww3.sinaimg.cn/large/59967359gw1eurz18tbpyj205f028dfp.jpg" alt="instance内部结构"></p>
<p>如果我们把instance1的操作改成</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var instance1 = new SubType();</div><div class="line">instance1.aa = 2;</div><div class="line">instance1.colors = [<span class="string">'red'</span>, <span class="string">'white'</span>, <span class="string">'yellow'</span>];</div></pre></td></tr></table></figure>
<p>这里的输出结果是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">instance1.aa=2 instance1.colors=red,white,yellow</div><div class="line">instance2.aa=1 instance2.colors=red,white,yellow</div></pre></td></tr></table></figure></p>
<p>好神奇！colors又不改变了！</p>
<p>再看看这时候两个是啥样子：</p>
<p><img src="http://ww4.sinaimg.cn/large/59967359jw1eurz9khcycj207d03ft8p.jpg" alt="instance内部结构2"></p>
<p>如果我们再改一下操作<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var instance1 = new SubType();</div><div class="line">SubType.prototype.aa = 2;</div></pre></td></tr></table></figure></p>
<p>这里输出结果果然是instance1和instance2的aa值都变成了2。</p>
<p>最后再看看这两个这时候是什么样子：<br><img src="http://ww4.sinaimg.cn/large/59967359gw1eurz2d69eyj207802mdfs.jpg" alt="instance内部结构2"></p>
<p>我们终于发现了问题！</p>
<p>继承后创建的实例对于引用类型和基本类型的操作貌似是不太一样的，对于基础类型，不管是赋值操作还是直接＋＋这样的操作，都会在实例中创建一个自己的属性，不会影响到原型，所以也就不用影响到其他的实例。如果想要影响所有实例，必须通过SubType.prototype来修改。</p>
<p>但对于引用类型，如果直接调用引用类型自己的方法，不会创建自己的属性，会通过原型链回溯，因此就修改到了子类型的原型上去了，其他实例也会跟着影响。而如果通过赋值的方式，则会创建一个自己的属性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;继承方法：&quot;&gt;&lt;a href=&quot;#继承方法：&quot; class=&quot;headerlink&quot; title=&quot;继承方法：&quot;&gt;&lt;/a&gt;继承方法：&lt;/h2&gt;&lt;h3 id=&quot;1、原型链（主要）&quot;&gt;&lt;a href=&quot;#1、原型链（主要）&quot; class=&quot;headerlink&quot; ti
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
</feed>
